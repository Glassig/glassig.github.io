<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta content="#26a69a" name="theme-color"><!-- Own css !-->
    <link href="../../style.css" rel="stylesheet" type="text/css"><!-- Compiled and minified CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css" rel="stylesheet"><!-- Socicon (social icons) -->
    <link href="https://file.myfontastic.com/n6vo44Re5QaWo8oCKShBs7/icons.css" rel="stylesheet"><!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><!--Import font-->
    <link href="https://fonts.googleapis.com/css?family=Space+Mono" rel="stylesheet"><!-- Favicon -->
    <link href="../../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
    <link href="../../manifest.json" rel="manifest">
    <title>SOLID!</title>
</head>
<body id="blog">
    <header>
        <div class="intro teal lighten-1 z-depth-1">
            <h1 class="grey-text text-lighten-4">&#123;Angelina's Blog&#125;</h1>
            <h4 class="grey-text text-lighten-4">SOLID!</h4>
            <div id="navigation">
                <h5 onclick="window.location = '/'">Main</h5>
                <h5 onclick="window.location = '/blog/index.html'" class="active">Blog</h5>
            </div>
        </div>
    </header>
    <main>
        <div class="container">
            <h5>Code for readability, always.</h5>
            <p>2019-10-01</p>
            <hr>
            <div class="row white" id="blog_content">
                
<style>
    .container h5:not(:first-child) {
        text-transform: none;
        font-variant: small-caps;
    }
</style>
    <p>
        SOLID was originally coined by Robert "Uncle Bob" C. Martin. There are thousands of blog posts about SOLID. Why would I add a drop to the ocean? <i>The short story:</i> it's hard to understand SOLID, and most of them are aimed at backend developers, while I want to talk about it from a frontend perspective (which there are blog posts about, but they are fewer and not as common). Also, I spent a lot of time decoding SOLID before I held a lecture on it, so might as well use that knowledge.
    </p><p>
        <i>Long story:</i> I read Clean Code in 2017, and I absolutely loved it. 10/10. You get really motivated to start coding so please have a computer nearby. I was on vacation and had decided to not bring a computer. Big mistake.
    </p><p>
        From that book, the only principle I really managed to adapt in my coding was SRP (keep reading). At the time, I was starting to get into web development, mostly frontend, and I found the others harder to understand and not as applicable. The part above about a lecture is true; me and a colleague was supposed to teach a group of junior developers SOLID, I signed up for it and then spent a lot of time researching it, because I did not get it. I wrote a mini essay trying to explain the principles to myself, so I thought I might as well publish it. It is also quite humorous to me that despite the fact that SOLID is aimed at Object Oriented Languages, which is not really what we think of when we think of frontend, I can still find examples and applications for SOLID for frontend. You are welcome.
    </p><p>
        <i>Side note:</i> I only had to present S, L, and D. My colleague took O and I. However, we explained it to each other and I helped them write their code examples, so I included those principles in this post. (I have also gotten their consent to use that information.)
    </p>
</div>
<h5>S = Single Responsibility Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>Every module/class/function should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. <i>A class should have only one reason to change</i>.</blockquote>
    <p>
        SRP was created by Robert C Martin while working for Xerox. He later clarified what it was about: “This principle is about people”. He thinks of the code from a business perspective, saying something like "the COO should not be fired for a change requested by the CTO". I find this explanation kind of hard to relate directly to code. I like using other titles; "the database engineer should not be fired for a change requested by the UX designer".
    </p>
    <p>
        I also like to try and explain every module/class/function without using the keywords "or", "and", "if", and "but". If I can't do it naturally, they maybe do too much.
    </p>
    <p>
        Let's continue talking about code: all these examples are written using Typescript, because it is what Javascript was supposed to be (fight me). With the exception of SRP, all examples are kind of joke:y, because why not. However, SRP is one of those principles, where it is easier with almost real code example. I also use pseudo-code, because the details are less important and would just be too much. The example is over the top, but I can almost guarantee that there are code out there that at some point started like this.
    </p>
<pre class="prettyprint">
export class User {
    public username: string;
    public email: string;
    constructor(private databaseRef: Database) {}
    public async loginAndInitUser() {
        // get credentials from user
        // check if user is in db
        // if is in db, populate the values and redirect user to main page
        // if not, return error
    }
}
</pre>
<p>
    How would you describe this code? The sentence I wrote goes like this:
    <blockquote>
        We are asking for login information from the user <b>and</b> then we check if they are in the database, <b>if</b> they are in the database we initiate all the variables <b>and</b> redirect the user to another page, <b>or</b> it returns an error.
    </blockquote>
    There are a lot of issues here. If the designer wants changes to the user flow, it will affect the user class. If the database engineer changes how the database works, it will affect the user class. If the security engineer changes how we handle credentials, it affects the user class. Solutions instead would be to make one part of the code handle the databse logic, instead of doing it from the lower level objects. Another class should handle the flow of the page. Maybe we shouldn't create the User until they have logged in. This is an extreme example, but when you want to quickly just create a prototype or similar, this might happen. And then you need to change it, and it will just ruin your day. Try and write code you are okay to go back to.
</p>
</div>
<h5>O = Open-Closed Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>
        Software entities should be open for extension, but closed for modification.
    </blockquote>
    <p>
        OCP was created by Bertrand Meyer in 1988. The idea here is that each class (or function) should be complete, given an abstract use case. Instead of changing the class to fit more use cases, you make it general and abstract so you can simply add to it. Simply and simply... it is not simple to explain in text. Let's instead look at some example code.
    </p>
<pre class="prettyprint">
class Chips {
    nutrition: number;
    weight: number;
}
function calcNutrition(chips: Chips) {
    return chips.nutrition * chips.weight;
}
</pre>
    <p>
        We have a class for Chips, and a function that calculates the nutritional value of the chips. It does so correctly, and we have no current bugs or problems with this code. However, the problems arrive when we want to include other food objects, for example: cucumber. We can either change the code in calcNutrition to include either chips or cucumber, and then depending on what it get use a different equation. Or should we write a completly new function for calculating the nutrition, and then put some logic in the calling function in order to decide which function to call? Both breaks the OCP, because we change the equation (or function), instead of extending it. Here is an alternative:
    </p>
<pre class="prettyprint">
interface IFood {
    ingredients: Ingredient[]; // custom class
}
class Chips implements IFood {}

function calculateNutrition(food: IFood) {
    let nutrition: number = 0;
    for(let ingredient of food.ingredients) {
        nutrition += ingredient.nutrition;
    }
    return nutrition;
}
</pre>
    <p>
        (Sidenote: the class Chips can still have the variables for nutrition and weight, but it doesn't matter for the example.) In this code example, we have created an interface for Food, and then made the calculateNutrition function dependent on that interface. Each food object just need to implement the Food interface, and the function will work. This means that calculateNutrition is open for extension; it can accept more and different foods. It is closed for modification though; we should not need to change it, as long as each food object correctly implements the food interface. 
    </p>
    <p>
        A few tips about following OCP: Make member variables private by default and only use <code>get</code> and <code>set</code> when needed. We don't want to depend on variables, it is better to depend on abstractions (more on this later). If there is a change in the variables or how they work, we need to modify all functions and objects that rely on them. Thus, they are open for modification.
    </p>
</div>
<h5>L = Liskov Substitution Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>
        If <i>S</i> is a subtype of <i>T</i>, then objects of type <i>T</i> may be replaced with objects of type S (i.e. an object of type <i>T</i> may be substituted with any object of a subtype <i>S</i>) without altering any of the desirable properties of the program (correctness, task performed, etc.).
    </blockquote>
    <p>
        I mean, that just makes it absolutely obvious what this is about, right? Right?... I feel like I read that a few times before I went to youtube. It is all about <i>Inheritance;</i> "Children should be like their parents for what they inherit". "Children should not override their parents". It is all about having the right abstraction. However, it is not that easy, unfortunately. LSP has several rules that makes it more complicated, because easy is just... easy. Let's go over them and see if I can explain it.
    </p>
    <ul>
        <li>
            <i>Contravariance</i> of method arguments.
            <ul>
                <li>
                    Children's input type could be either the same type, or the supertype, of the parent's input type.
                </li>
                <li>For example: if a function in the parent accept "Car" as an input, the child can either accept "Car" or maybe "Vehicle".</li>
                <li>The idea is that the child should accept all the inputs that the parent can accept.</li>
            </ul>
        </li>
        <li>
            <i>Covariance</i> of the return types.
            <ul>
                <li>
                    Children's return type can be either the same type, or a subtype, of the parent's return type.
                </li>
                <li>For example: if the parent returns "Vehicle", the child can return "Vehicle" or maybe "Car".</li>
                <li>The idea here is that the parent can handle all the different returns that the child can.</li>
            </ul>
        </li>
        <li>
            No new exceptions, except for subtypes of the parent's exception.
            <ul>
                <li>
                    The parent should be able to handle all errors that a child might throw.
                </li>
            </ul>
        </li>
        <li>
            <i>Preconditions</i> should not be strengthened in the child.
            <ul>
                <li>
                    Preconditions are rules that must be true <i>before</i> executing a piece of code.
                </li>
                <li>
                    Essentially, don't add conditionals or other checks in the child.
                </li>
            </ul>
        </li>
        <li>
            <i>Postconditions</i> should not be weakened in a child.
            <ul>
                <li>
                    Postconditions are rules that must be true <i>after</i> executing a piece of code.
                </li>
                <li>
                    So, if you say that a function in the parent will return a number that is an integer larger than one, then the child needs to do the same. If the child instead will only return an integer (not necessarily larger than one), it has been weakened.
                </li>
            </ul>
        </li>
        <li>
            <i>Invariants</i> of a parent must be the same in a child.
            <ul>
                <li>
                    Invariants mean the rules during the existance of an object.
                </li>
                <li>
                    Basically, if a certain set of conditions results in an error in the parent, the same conditions should result in an error in the child. The child should have the same behaviour.
                </li>
            </ul>
        </li>
        <li>
            <i>The History Rule</i>
            <ul>
                <li>
                    The History Rule states that a child cannot modify objects that the parent has as imutable.
                </li>
            </ul>
        </li>
    </ul>
    <p>Now that all of that is out of the way, let's check out some code. It should make it more clear. Let's begin with a Duck:</p>
<pre class="prettyprint">
export class Duck {
    public movedDistance: number = 0;
    constructor(protected duckName: string) {};
    public get name(): string {
        return this.duckName;
    }
    public duckGo(meters: number) {
        this.movedDistance += meters;
    }
    public talk(): string {
        return "Quack";
    }
}
</pre>
    <p>This is a duck. It has a "private" (protected is special, I will explain soon) variable for name, it can walk and it can talk. There is nothing wrong with this code. But, let's say we need to make another class, and it seems kind of similar to Duck, and since Duck is good code, why not just inherit from it?</p>
<pre class="prettyprint">
export class ToyDuck extends Duck {
    private batteryPercentage: number = 100;
    public duckGo(meters: number) {
        if (this.batteryPercentage < 5) {
            throw new LowBatteryException();
        }
        this.movedDistance += meters * 2;
        this.batteryPercentage -= 5;
    }
    public set name(value: string) {
        this.duckName = value;
    }
    public talk(name?: string): string {
        return `Quack quack ${name != null ? name : 'owner'}`;
    }
}
</pre>
    <p>So, we have a toy duck that is inherited from duck. Both are ducks, right? Nothing wrong with this, right? Actually, let's look a little closer.</p>
    <p>In ToyDuck, we have a variable for keeping track of the battery. There is nothing wrong with extending the class, so this is okay. However, in the function for walking (duckGo), we check the battery levels, thus we have strengthened the preconditions. We also throw a new error if the battery levels are too low. The ToyDuck is faster than the duck, so we don't even have the same behaviour (Invariants rule). We break the history rule by allowing for the name to be changed. The reason I used "protected" in Typescript is because it allows for children to change otherwise private variables (if we used the private keyword it would not compile). So the code works, but it breaks the LSP. The talk-function accepts input, but the parent does not (the questionmark means it is optional). I want to add that the talk function is otherwise okay; we still return a string, it is okay to change what the string is.</p>
    <p>I used a common saying in regards to LSP for the idea behind this code:</p>
    <blockquote>If it walks like a duck, talks like a duck, but needs batteries, then you probably have the wrong abstraction.</blockquote>
    <p>This qoute is really nice. If we think about it, a toy duck is not a duck. We might think they are similar, but really, a toy duck is a toy. Not a duck. This example is a bit obvious, which it might not be when talking about the code we do daily. Some things will have similar names, but really, they are not alike. If you have to modify the parent in order to inherit from it, maybe you should not inherit from it at all.</p>
</div>
<h5>I = Interface Segregation Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>No client should be forced to depend on methods it does not use.</blockquote>
    <p>
        There were too many principles without Uncle Bob, it felt weird there for a second. But, here he is, back at it. You would not be wrong if the one thing you took with you from this blog post is that "Interface good". Interfaces are good. However, as with everything, even good things can be made bad. I guess the second thing you should get from this post is "Abstractions good, if right". If you have the right abstraction, and the right interfaces, your code should be more readable and more open for extension.</p>
    <p>
        Try and keep your interfaces or abstract classes small. If the language allows it (I know Typescript does), you can have interfaces that implements another interface, or have a class that inherits from multiple interfaces. It is better with more, consise and clear interfaces, than a few complex. It also allows for an easier time making edits to the code. Speaking of which!
    </p>
<pre class="prettyprint">
interface IElectricalDevice {
    HDMI(): void;
    VGA(): void;
    USB(): void;
    RCA(): void;
    threepointfive(): void
}
class Headset implements IElectricalDevice {
    HDMI(): void {};
    VGA(): void {};
    USB(): void {};
    RCA(): void {};
    threepointfive(): void {};
}
</pre>
    <p>
        In reality there is nothing wrong with calling an headset for an electrical device, but it makes it a lot more cluttered in code. When implementing the interface "IElectricalDevice", we force the coder to implement a lot more than it should. You might have seen code in similar situations where there will be a comment inside the function "Never called, don't worry" or similar. But, that just means that you are looking at a bunch of unecessary stuff. Right abstraction for your goals is key:
    </p>
<pre class="prettyprint">
interface AudioDevice {
    threepointfive(): void;
    RCA(): void;
}
class Headphones implements AudioDevice {
    threepointfive(): void {};
    RCA(): void {};
}
interface VideoDevice {
    HDMI(): void;
    VGA(): void;
}
</pre>
</div>
<h5>D = Dependency Inversion Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>
        A: High level modules should not depend upon low level modules. Both should depend on abstraction. <br>
        B: Abstractions should not depend upon details. Details should depend upon abstractions.
    </blockquote>
    <p>
        We finish this long treck with a principle written by Uncle Bob, about abstractions. It is better to support abstractions. The less a coder need to read in order to understand what is done in each function or class, the better. A general rule of thumb is to consider abstract input vs initiating a specific object.
    </p>
<pre class="prettyprint">
class Cat {
    public eat() {
        // consume cat food
    }
}
class Caretaker {
    private subject: Cat;
    constructor() {
        this.subject = new Cat();
    }
    public feedYourSubject() {
        this.subject.eat();
    }
}    
</pre>
    <p>
        In this piece of code, we are dependent on the implementation of Cat inside Caretaker. If we want the Caretaker to be able to take care of more kinds of animals than cats, we need to change a lot. Also consider this; let's say you have a fancy schmancy intellisense-similar program inside your editor to give you information about a function or class when you write it. Let's say you initiate a Caretaker object somewhere else in your code, what will that program tell you about Caretaker? Or you are just reading code where Caretaker is initialized, what will you get from it?
    </p>
    <blockquote><code>new Caretaker();</code></blockquote>
    <p>Not a whole lot. You might even think that it is just doing it's own thing.</p>
<pre class="prettyprint">
export interface IAnimal {
    eat(): void;
}
export class Cat implements IAnimal {
    public eat() {
        // consume catfood
    }
}
export class Caretaker {
    constructor(private subject: IAnimal) {} // it just needs to be an animal
    public feedYourSubject() {
        this.subject.eat();
    }
}
</pre>
    <p>
        In here Caretaker depend on the abstract class IAnimal. We can extend this program by creating more animals that implements IAnimal, and we don't need to change Caretaker when we do. Also, that fancy program:
    </p>
    <blockquote><code>new Caretaker(subject: IAnimal);</code></blockquote>
    <p>
        That tells us a lot more. We now know what Caretaker depends on, and that tells us a lot more on how it works. And we don't need to go into the file to get it.
    </p>
            </div>
        </div>
    </main>
    <i  class="material-icons navigation_button icon"
        id="arrow_back"
        onclick="window.location = '1.rebase.html'"
    >arrow_back_ios</i>
    <i  class="material-icons navigation_button icon"
        id="arrow_forward"
        onclick="window.location = '2.solid.html'"
        >arrow_back_ios</i>
    <footer class="page-footer teal lighten-1 grey-text text-lighten-4">
        <div class="row contact-footer">
            <div class="col s4 m4 l4"></div>
            <div class="col s4 m2 l2"><img alt="Contact me!" class="circle responsive-img" src="../../images/valtech_photo_cropped.png"></div>
            <div class="col s12 m6 l6 left-align">
                <ul class="socials">
                    <li>
                        <a class="socicon-linkedin btn footerButton" href="https://se.linkedin.com/in/angelina-von-gegerfelt">Linkedin</a>
                    </li>
                    <li>
                        <a class="socicon-github btn footerButton" href="https://github.com/glassig">Github</a>
                    </li>
                    <li>
                        <a class="socicon-mail btn footerButton" href="mailto:angelina.v.gegerfelt@gmail.com">Email</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="footer-copyright">
            <div class="grey-text text-lighten-2 right-align">
                &#x24B8; 2019 Angelina von Gegerfelt
            </div>
        </div>
    </footer><!--Import jQuery before materialize.js-->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js">
    </script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</body>
</html>