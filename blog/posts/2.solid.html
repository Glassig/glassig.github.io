<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <meta content="#26a69a" name="theme-color"><!-- Own css !-->
    <link href="../../style.css" rel="stylesheet" type="text/css"><!-- Compiled and minified CSS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/css/materialize.min.css" rel="stylesheet"><!-- Socicon (social icons) -->
    <link href="https://file.myfontastic.com/n6vo44Re5QaWo8oCKShBs7/icons.css" rel="stylesheet"><!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"><!--Import font-->
    <link href="https://fonts.googleapis.com/css?family=Space+Mono" rel="stylesheet"><!-- Favicon -->
    <link href="../../images/favicon.ico" rel="shortcut icon" type="image/x-icon">
    <link href="../../manifest.json" rel="manifest">
    <title>SOLID!</title>
</head>
<body id="blog">
    <header>
        <div class="intro teal lighten-1 z-depth-1">
            <h1 class="grey-text text-lighten-4">&#123;Angelina's Blog&#125;</h1>
            <h4 class="grey-text text-lighten-4">SOLID!</h4>
            <div id="navigation">
                <h5 onclick="window.location = '/'">Main</h5>
                <h5 onclick="window.location = '/blog/index.html'" class="active">Blog</h5>
            </div>
        </div>
    </header>
    <main>
        <div class="container">
            <h5>Code for readability, always.</h5>
            <p>2019-10-01</p>
            <hr>
            <div class="row white" id="blog_content">
                
<style>
    .container h5:not(:first-child) {
        text-transform: none;
        font-variant: small-caps;
    }
</style>
    <p>
        SOLID was originally coined by Robert "Uncle Bob" C. Martin. There are thousands of blog posts about SOLID. Why would I add a drop to the ocean? <i>The short story:</i> it's hard to understand SOLID, and most of them are aimed at backend developers, while I want to talk about it from a frontend perspective (which there are blog posts about, but they are fewer and not as common). Also, I spent a lot of time decoding SOLID before I held a lecture on it, so might as well share that knowledge. It is also quite humorous to me that right now, SOLID is <i>very</i> relevant for frontend development, despite it usually being considered backend territory. Typescript and the emergance of "object oriented thinking" in frameworks like React has made it something frontend peeps should learn.
    </p><p>
        <i>Side note:</i> I only had to present S, L, and D. My colleague took O and I. However, we explained it to each other and I helped them write their code examples, so I included those principles in this post. (I have also gotten their consent to use that information.)
    </p>
</div>
<h5>S = Single Responsibility Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>Every module/class/function should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. <i>A class should have only one reason to change</i>.</blockquote>
    <p>
        The method I use in order to consider whether or not my code follows SRP is this: I like to try and explain every module/class/function without using the keywords "or", "and", "if", and "but". If I can't do it naturally, they maybe do too much.
    </p>
    <p>
        Let's continue talking about code: all these examples are written using Typescript, because it is what Javascript was supposed to be (fight me). With the exception of SRP, where I use pseudo-code, because the details are less important and would just be too much. The example is over the top, but I can almost guarantee that there are code out there that at some point started like this.
    </p>
<pre class="prettyprint">
export class User {
    public username: string;
    public email: string;
    constructor(private databaseRef: Database) {}
    public async loginAndInitUser() {
        // get credentials from user
        // check if user is in db
        // if is in db, populate the values and redirect user to main page
        // if not, return error
    }
}
</pre>
<p>
    How would you describe this code? The sentence I wrote goes like this:
    <blockquote>
        We are asking for login information from the user <b>and</b> then we check if they are in the database, <b>if</b> they are in the database we initiate all the variables <b>and</b> redirect the user to another page, <b>or</b> it returns an error.
    </blockquote>
    There are a lot of issues here. The user handles too much, and login has side-effects you might not know about if you were to call upon it from another file and only reads the method name. I think the over the top example needs no more explanation that <i>it bad</i>, but I encourage you to look at "cleaner" code and see, are there one too many repsonsibilities?
</p>
</div>
<h5>O = Open-Closed Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>
        Software entities should be open for extension, but closed for modification.
    </blockquote>
    <p>
        OCP was created by Bertrand Meyer in 1988. The idea here is that each class (or function) should be complete, given an abstract use case. Instead of changing the class to fit more use cases, you make it general and abstract so you can simply add to it. Simply and simply... it is not simple to explain in text. Let's instead look at some example code.
    </p>
<pre class="prettyprint">
class Chips {
    nutrition: number;
    weight: number;
}
function calculateNutrition(chips: Chips) {
    return chips.nutrition * chips.weight;
}
</pre>
    <p>
        We have no current bugs or problems with this code. However, the problems arrive when we want to include other food objects. We can either change the code in calculateNutrition to acept input of either food type, and then depending on what it get use a different equation. Or should we write a completly new function for calculating the nutrition, and then put some logic in the calling function in order to decide which function to call? Both breaks the OCP, because we change the equation (or function), instead of extending it. Here is an alternative:
    </p>
<pre class="prettyprint">
interface IFood {
    ingredients: Ingredient[]; // custom class
}
class Chips implements IFood {}

function calculateNutrition(food: IFood) {
    let nutrition: number = 0;
    for(let ingredient of food.ingredients) {
        nutrition += ingredient.nutrition;
    }
    return nutrition;
}
</pre>
    <p>
        (Sidenote: the class Chips can still have the variables for nutrition and weight, but it doesn't matter for the example.) In this code example, we have created an interface for Food, and then made the calculateNutrition function dependent on that interface. Each food object just need to implement the Food interface, and the function will work. This means that calculateNutrition is open for extension; it can accept more and different foods. It is closed for modification though; we should not need to change it, as long as each food object correctly implements the food interface. 
    </p>
</div>
<h5>L = Liskov Substitution Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>
        If <i>S</i> is a subtype of <i>T</i>, then objects of type <i>T</i> may be replaced with objects of type S (i.e. an object of type <i>T</i> may be substituted with any object of a subtype <i>S</i>) without altering any of the desirable properties of the program (correctness, task performed, etc.).
    </blockquote>
    <p>
        I felt like I read that a few times before I went to youtube. It is all about <i>Inheritance;</i> "Children should be like their parents for what they inherit". "Children should not override their parents". It is all about having the right abstraction. However, it is not that easy, unfortunately. LSP has several rules that makes it more complicated, because easy is just... easy. I have tried to summarize them quickly, one day I might make a better job at it.
    </p>
    <ul>
        <li>
            Children's input type could be either the same type, or the supertype, of the parent's input type.
        </li>
        <li>
            Children's return type can be either the same type, or a subtype, of the parent's return type.
        </li>
        <li>
            No new exceptions, except for subtypes of the parent's exception.
        </li>
        <li>
            Rules that must be true <i>before</i> executing a piece of code should not be strengthened in the child.
        </li>
        <li>
            Rules that must be true <i>after</i> executing a piece of code should not be weakened in a child.
        </li>
        <li>
            Rules during the existance of a parent must be the same in a child.
        </li>
        <li>
            A child cannot modify objects that the parent has as imutable.
        </li>
    </ul>
    <p>Now that all of that is out of the way, let's check out some code. It should make it more clear. Let's begin with a Duck:</p>
<pre class="prettyprint">
export class Duck {
    public movedDistance: number = 0;
    constructor(protected duckName: string) {};
    public get name(): string {
        return this.duckName;
    }
    public duckGo(meters: number) {
        this.movedDistance += meters;
    }
    public talk(): string {
        return "Quack";
    }
}
</pre>
    <p>This is a duck. It has a "private" (protected is special, I will explain soon) variable for name, it can walk and it can talk. There is nothing wrong with this code. But, let's say we need to make another class, and it seems kind of similar to Duck, and since Duck is good code, why not just inherit from it?</p>
<pre class="prettyprint">
export class ToyDuck extends Duck {
    private batteryPercentage: number = 100;
    public duckGo(meters: number) {
        if (this.batteryPercentage < 5) {
            throw new LowBatteryException();
        }
        this.movedDistance += meters * 2;
        this.batteryPercentage -= 5;
    }
    public set name(value: string) {
        this.duckName = value;
    }
    public talk(name?: string): string {
        return `Quack quack ${name != null ? name : 'owner'}`;
    }
}
</pre>
    <p>In ToyDuck, we have a variable for keeping track of the battery. There is nothing wrong with extending the class, so this is okay. However, in the function for walking (duckGo) we check the battery levels, we also throw a new error if the battery levels are too low. The ToyDuck is faster than the duck, so we don't even have the same behaviour. We allow for a private variable to be changed (name). The reason I used "protected" in Typescript is because it allows for children to change otherwise private variables (if we used the private keyword it would not compile). So the code works, but it breaks the LSP. The talk-function accepts input, but the parent does not (the questionmark means it is optional). I want to add that the talk function is otherwise okay; we still return a string, it is okay to change what the string is.</p>
    <p>I used a common saying in regards to LSP for the idea behind this code:</p>
    <blockquote>If it walks like a duck, talks like a duck, but needs batteries, then you probably have the wrong abstraction.</blockquote>
    <p>A toy duck is not a duck. We might think they are similar, but really, a toy duck is a toy. This example is a bit obvious, which it might not be when talking about the code we do daily. Some things will have similar names, but really, they are not alike. If you have to modify the parent in order to inherit from it, maybe you should not inherit from it at all.</p>
</div>
<h5>I = Interface Segregation Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>No client should be forced to depend on methods it does not use.</blockquote>
    <p>
        You would not be wrong if the one thing you took with you from this blog post is that "Interface good". Interfaces are good. However, as with everything, even good things can be made bad. I guess the second thing you should get from this post is "Abstractions good, if right". If you have the right abstraction, and the right interfaces, your code should be more readable and more open for extension. Try and keep your interfaces or abstract classes small.
    </p>
<pre class="prettyprint">
interface IElectricalDevice {
    HDMI(): void;
    VGA(): void;
    USB(): void;
    RCA(): void;
    threepointfive(): void
}
class Headset implements IElectricalDevice {
    HDMI(): void {};
    VGA(): void {};
    USB(): void {};
    RCA(): void {};
    threepointfive(): void {};
}
</pre>
    <p>
        In reality there is nothing wrong with calling an headset for an electrical device, but it makes it a lot more cluttered in code. When implementing the interface "IElectricalDevice", we force the coder to implement a lot more than it should. You might have seen code in similar situations where there will be a comment inside the function "Never called, don't worry" or similar. But, that just means that you are looking at a bunch of unecessary stuff. Right abstraction for your goals is key:
    </p>
<pre class="prettyprint">
interface AudioDevice {
    threepointfive(): void;
    RCA(): void;
}
class Headphones implements AudioDevice {
    threepointfive(): void {};
    RCA(): void {};
}
interface VideoDevice {
    HDMI(): void;
    VGA(): void;
}
</pre>
</div>
<h5>D = Dependency Inversion Principle</h5>
<hr>
<div class="row white" id="blog_content">
    <blockquote>
        A: High level modules should not depend upon low level modules. Both should depend on abstraction. <br>
        B: Abstractions should not depend upon details. Details should depend upon abstractions.
    </blockquote>
    <p>
        This principle summarized in a few words: it is better to support abstractions. The less a coder need to read in order to understand what is done in each function or class, the better. A general rule of thumb is to consider abstract input vs initiating a specific object.
    </p>
<pre class="prettyprint">
class Cat {
    public eat() {
        // consume cat food
    }
}
class Caretaker {
    private subject: Cat;
    constructor() {
        this.subject = new Cat();
    }
    public feedYourSubject() {
        this.subject.eat();
    }
}    
</pre>
    <p>
        In this piece of code, we are dependent on the implementation of Cat inside Caretaker. If we want the Caretaker to be able to take care of more kinds of animals than cats, we need to change a lot. Also consider this; let's say you have a fancy schmancy intellisense-similar program inside your editor to give you information about a function or class when you write it. Let's say you initiate a Caretaker object somewhere else in your code, what will that program tell you about Caretaker? Or you are just reading code where Caretaker is initialized, what will you get from it?
    </p>
    <blockquote><code>new Caretaker();</code></blockquote>
    <p>
        Not a whole lot. You might even think that Caretaker is just doing it's own thing.
    </p>
<pre class="prettyprint">
export interface IAnimal {
    eat(): void;
}
export class Cat implements IAnimal {
    public eat() {
        // consume catfood
    }
}
export class Caretaker {
    constructor(private subject: IAnimal) {} // it just needs to be an animal
    public feedYourSubject() {
        this.subject.eat();
    }
}
</pre>
    <p>
        In here Caretaker depend on the abstract class IAnimal. We can extend this program by creating more animals that implements IAnimal, and we don't need to change Caretaker when we do. Also, that fancy program:
    </p>
    <blockquote><code>new Caretaker(subject: IAnimal);</code></blockquote>
    <p>
        That tells us a lot more. We now know what Caretaker depends on, and that tells us a lot more on how it works. And we don't need to go into the file to get it.
    </p>
</div>
<h5>The End</h5>
<hr>
<div class="row white" id="blog_content">
    <p>Well, wasn't that just... a lot. Sorry for the long post. I hope you got something out of it, now go forth! Write nice programs! And let me know if anything is badly explained. Because it probably is. Thanks!</p>
            </div>
        </div>
    </main>
    <i  class="material-icons navigation_button icon"
        id="arrow_back"
        onclick="window.location = '1.rebase.html'"
    >arrow_back_ios</i>
    <i  class="material-icons navigation_button icon"
        id="arrow_forward"
        onclick="window.location = '2.solid.html'"
        >arrow_back_ios</i>
    <footer class="page-footer teal lighten-1 grey-text text-lighten-4">
        <div class="row contact-footer">
            <div class="col s4 m4 l4"></div>
            <div class="col s4 m2 l2"><img alt="Contact me!" class="circle responsive-img" src="../../images/valtech_photo_cropped.png"></div>
            <div class="col s12 m6 l6 left-align">
                <ul class="socials">
                    <li>
                        <a class="socicon-linkedin btn footerButton" href="https://se.linkedin.com/in/angelina-von-gegerfelt">Linkedin</a>
                    </li>
                    <li>
                        <a class="socicon-github btn footerButton" href="https://github.com/glassig">Github</a>
                    </li>
                    <li>
                        <a class="socicon-mail btn footerButton" href="mailto:angelina.v.gegerfelt@gmail.com">Email</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="footer-copyright">
            <div class="grey-text text-lighten-2 right-align">
                &#x24B8; 2019 Angelina von Gegerfelt
            </div>
        </div>
    </footer><!--Import jQuery before materialize.js-->
    <script src="https://code.jquery.com/jquery-3.3.1.min.js"></script>
    <!-- Compiled and minified JavaScript -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/0.97.7/js/materialize.min.js">
    </script>
    <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</body>
</html>